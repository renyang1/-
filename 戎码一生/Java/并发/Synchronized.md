### synchronized

synchronized关键字解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。

**synchronized关键字最主要的三种使用方式：**

- **修饰实例方法:** 作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁
- **修饰静态方法:** :也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（ static 表明这是该类的一个静态资源，不管new了多少个对象，只有一份）。所以如果一个线程A调用一个实例对象的非静态 synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，**因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁**。
- **修饰代码块:** 指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。

**注意：**==synchronized保护的是**对象**而非代码==，只要访问的是同一个对象的synchronized方法，即使是不同的代码，也会被同步顺序访问。多个线程是可以同时执行同一个synchronized实例方法的，只要它们访问的对象是不同。

**总结：** synchronized 关键字加到 static 静态方法和 synchronized(class)代码块上都是是给 Class 类上锁。synchronized 关键字加到实例方法上是给对象实例上锁。尽量不要使用 synchronized(String a) 因为JVM中，字符串常量池具有缓存功能！

**synchronized特点**

- 可重入性
- 内存可见性
- 死锁

**可重入性**

对同一个执行线程，它在获得了锁之后，在调用其他需要同样锁的代码时，可以直接调用，比如说，在一个synchronized实例方法内，可以直接调用其他synchronized实例方法。可重入是通过记录锁的持有线程和持有数量来实现的，当调用被synchronized保护的代码时，检查对象是否已被锁，如果是，再检查是否被当前线程锁定，如果是，增加持有数量，如果不是被当前线程锁定，才加入等待队列，当释放锁时，减少持有数量，当数量变为0时才释放整个锁。

**内存可见性**

synchronized除了保证原子操作外，它还有一个重要的作用，就是保证内存可见性，**在释放锁时，所有写入都会写回内存，而获得锁后，都会从内存中读最新数据**。不过，如果只是为了保证内存可见性，使用synchronzied的成本有点高，有一个更轻量级的方式，那就是给变量加修饰符**volatile**。

**死锁**

使用synchronized或者其他锁，要注意死锁，所谓死锁就是类似这种现象，比如， 有a, b两个线程，a持有锁A，在等待锁B，而b持有锁B，在等待锁A，a,b陷入了互相等待，最后谁都执行不下去。应该尽量避免在持有一个锁的同时去申请另一个锁，如果确实需要多个锁，所有代码都应该==按照相同的顺序去申请锁==。在复杂的项目代码中，这种约定可能难以做到，可以使用**显式锁接口Lock**，它支持尝试获取锁(tryLock)和带时间限制的获取锁方法，使用这些方法可以在获取不到锁的时候释放已经持有的锁，然后再次尝试获取锁或干脆放弃，以避免死锁。

